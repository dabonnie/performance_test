"""
Script used to plot the output experiments generated by the run_relational_experiment module. This combines all of the
experiments found in each topic directory in order to plot them all with message rate and number of subscribers as
respective x-axis fields.

@author Devin Bonnie <dbbonnie@amazon.com>
"""

import matplotlib

matplotlib.use('Agg')
import operator
from collections import defaultdict
import matplotlib.pyplot as plt
import argparse
import pandas as pd
import os
from datetime import timedelta
import matplotlib.backends.backend_pdf
import math
import re

# header offset for the ApexAI experiment output
APEX_HEADER_LENGTH = 17 + 1
# valid topic names (excluding message sizes)
TOPIC_KEYS = ['Array', 'Struct', 'PointCloud', 'Range', 'NavSatFix', 'RadarDetection', 'RadarTrack']
# dict used for displaying desired x-axis field
PRETTY_PRINT_ATTRIBUTES = {'message_size': 'Message Size', 'rate': 'Message Rate (Hz)',
                           'num_subscribers': 'Number of Subscribers', 'topic_and_size': "Message Type and Size"}


def convert_size(input_size):
    """
    Return the input size (from the experiment) as a float in megabits per second.

    :param input_size: ApexAI topic string for the experiment size
    :return: megabits per second
    """
    if 'k' in input_size:
        split = input_size.split('k')
        return int(split[0]) * 8.0 / 1024.0

    elif 'm' in input_size:
        split = input_size.split('m')
        return int(split[0]) * 8

    else:
        return int(input_size) * 8 / math.pow(1024, 2)


class Experiment:
    """
    Class encapsulating the experiment fields from the Apex log file. Albeit somewhat clunky this aggregates single
    experiment data making it much easier to compare multiple experiments in a single plot.

    If so desired the fields can be changed (or TODO use a dict to store data) in the read_file_as_data_frame function.

    """

    def __init__(self, topic, message_size, rate, num_publishers, num_subscribers, reliability, durability, security):

        self.topic = topic  # this is simply the name, does not include size
        self.message_size_bytes = convert_size(message_size)
        self.topic_and_size = topic + message_size
        self.rate = int(rate)
        self.num_publishers = int(num_publishers)
        self.num_subscribers = int(num_subscribers)
        self.reliability = reliability
        self.durability = durability
        self.security = security

        # message counts
        self.lost_mean = []
        self.lost_stdev = []
        self.lost_max = []

        # measurements in milli-seconds
        self.latency_mean = []
        self.latency_stdev = []
        self.latency_max = []

        self.data_rx_max = []
        self.data_rx_mean = []
        self.data_rx_stdev = []

        # received and sent counts
        self.received_mean = []
        self.sent_mean = []

        self.length = 0  # set when the experiment data is populated

    def __str__(self):
        return str(self.__dict__)

    def to_plot_title(self, x_axis):

        variable_args = ""
        if x_axis == 'rate':
            variable_args += PRETTY_PRINT_ATTRIBUTES['num_subscribers'] + '=' + str(self.num_subscribers)
        elif x_axis == 'num_subscribers':
            variable_args += PRETTY_PRINT_ATTRIBUTES['rate'] + '=' + str(self.rate)

        return 'Topic ' + self.topic_and_size + ' ' + variable_args + '\nreliability=' + str(self.reliability) \
               + ' durability=' + str(self.durability) + ' security=' + str(self.security)

    def to_file_name(self, key, x_axis):
        """
        Return the file name to use for this experiment
        :param key:
        :param x_axis:
        :return:
        """
        return self.to_plot_title().replace('Topic', 'topic').replace(' ', '_') + '_' + str(key) + '_vs_' \
               + str(x_axis) + '.png'


def validate_topic(to_validate):
    """
    Check if the input is a valid topic. Note: this just checks the mesage type, not the size.

    :param to_validate:
    :return: True if the topic is valid, False otherwise
    """

    for topic in TOPIC_KEYS:
        if topic not in to_validate:
            continue
        else:
            return True

    return False


def parse_topic(to_parse):
    """
    Parse the topic field from the Apex experiment file and separate message type and size. For example, the input
    Struct256 will be returned as [Struct, 256].

    :param to_parse:
    :return:
    """
    for key in TOPIC_KEYS:
        if key in to_parse:
            return [key, to_parse.split(key)[1]]
    return None


def parse_experiment_header(header_lines):
    """
    Parse the header from the Apex experiment output log. E.g.

    Experiment id: 66de774a-9670-41cc-b4eb-bbe663546907
    Logfile name: experiment_topic_Struct256_rate_100_s3_l.log_Struct256_18-02-2019_13-20-36
    Communication mean: ROS2
    DDS domain id: 0
    QOS: Reliability: BEST_EFFORT Durability: VOLATILE History kind: KEEP_ALL History depth: 1000 Sync. pub/sub: 0
    Publishing rate: 100
    Topic name: Struct256
    Maximum runtime (sec): 0
    Number of publishers: 1
    Number of subscribers:3
    Memory check enabled: 0
    Use ros SHM: 0
    Use single participant: 0
    Not using waitset: 0
    Not using Connext DDS Micro INTRA: 0
    With security: 0

    :return:
    """

    if len(header_lines) < 14:
        return None

    reliability = re.findall("Reliability: ([A-Z_]+)", header_lines[4])[0]
    durability = re.findall("Durability: ([A-Z_]+)", header_lines[4])[0]
    rate = header_lines[5].replace(' ', '').split(':')[1]
    topic_size = parse_topic(header_lines[6].split(': ')[1])
    num_publishers = header_lines[8].replace(' ', '').split(':')[1]
    num_subscribers = header_lines[9].replace(' ', '').split(':')[1]
    security = header_lines[14].replace(' ', '').split(':')[1] == '1'

    return Experiment(topic_size[0], topic_size[1], rate, num_publishers, num_subscribers, reliability, durability,
                      security)


def read_file_as_data_frame(file_name):
    """
    Read the Apex experiment log file and parse the desired data.

    :param file_name: input Apex experiment file to read
    :return: an experiment instance populated with the desired data for plotting
    """

    # todo check if file exists
    print('    Parsing ' + file_name)
    with open(file_name) as opened_file:
        header = [next(opened_file).rstrip() for _x in range(17)]

    # todo experiment should just take the input data frame from the constructor
    experiment = parse_experiment_header(header)

    data_frame = pd.read_csv(file_name, skiprows=APEX_HEADER_LENGTH, sep="[ \t]*,[ \t]*", engine='python')

    experiment.length = len(data_frame['lost'])

    # get the latency mean, latency max, lost info from the data frame and average them
    if not data_frame.empty:
        experiment.lost_mean = data_frame['lost'].mean()
        experiment.lost_stdev = data_frame['lost'].std()
        experiment.lost_max = data_frame['lost'].max()

        experiment.latency_mean = data_frame['latency_mean (ms)'].mean()
        experiment.latency_stdev = data_frame['latency_mean (ms)'].std()
        experiment.latency_max = data_frame['latency_max (ms)'].max()

        experiment.data_rx_mean = data_frame['data_received'].mean()
        experiment.data_rx_stdev = data_frame['data_received'].std()
        experiment.data_rx_max = data_frame['data_received'].max()

        experiment.received_mean = data_frame['received'].mean()
        experiment.sent_mean = data_frame['sent'].mean()

    return experiment


def plot_all(x_axis_field, experiments, plotted_file_name=None):
    """

    :param plotted_file_name: file name for this plot if desired to save
    :param x_axis_field: x-axis for input experiments, currently rate or num_subscribers
    :param experiments: experiment list to plot
    :return: figure result from plotting
    """
    x_data = []

    lost_max = []
    lost_mean = []
    lost_error = []

    latency_max = []
    latency_mean_mean = []
    latency_mean_error = []

    data_rx_max = []
    data_rx_mean = []
    data_rx_error = []

    received_mean = []
    sent_mean = []

    duration_seconds = experiments[0].length

    # collect all experiment data
    for e in experiments:
        # todo check values: Apex experiments can have Nan or Inf

        x_data.append(getattr(e, x_axis_field))

        lost_max.append(e.lost_max)
        lost_mean.append(e.lost_mean)
        lost_error.append(e.lost_stdev)

        latency_mean_mean.append(e.latency_mean)
        latency_mean_error.append(e.latency_stdev)
        latency_max.append(e.latency_max)

        data_rx_max.append(e.data_rx_max)
        data_rx_mean.append(e.data_rx_mean)
        data_rx_error.append(e.data_rx_stdev)

        received_mean.append(float(e.received_mean * e.message_size_bytes))
        sent_mean.append(float(e.sent_mean) * e.message_size_bytes)

    plt.style.use('ggplot')
    figure_1, (axis_1, axis_2, axis_3) = plt.subplots(3, 1)

    # ------------------------------------------------------------------------------------------------------------------
    plot(axis_1, x_data, lost_mean, {'marker': 'o', 'linestyle': '-', 'markersize': '3'},
         plot_label='Lost Messages Mean',
         error=lost_error)
    plot(axis_1, x_data, lost_max, {'marker': 'x', 'linestyle': '--', 'markersize': '4'},
         plot_label='Lost Messages Max')

    axis_1.set_ylabel("# Lost Messages", fontsize=8)
    axis_1.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=6)

    # ------------------------------------------------------------------------------------------------------------------
    plot(axis_2, x_data, latency_mean_mean, {'marker': 'o', 'linestyle': '-', 'markersize': '3'},
         plot_label='Latency Mean',
         error=latency_mean_error)
    plot(axis_2, x_data, latency_max, {'marker': 'x', 'linestyle': '--', 'markersize': '4'}, plot_label='Latency Max')

    axis_2.set_ylabel("Latency Mean (ms)", fontsize=8)
    axis_2.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=6)

    # ------------------------------------------------------------------------------------------------------------------

    plot(axis_3, x_data, received_mean, {'marker': 'o', 'linestyle': '-', 'markersize': '3'},
         plot_label='Received Mean')

    plot(axis_3, x_data, sent_mean, {'marker': 'x', 'linestyle': '--', 'markersize': '4'}, plot_label='Sent Mean')

    axis_3.set_ylabel("Megabits per second", fontsize=8)
    axis_3.legend(loc='center left', bbox_to_anchor=(1, 0.5), fontsize=6)

    # ------------------------------------------------------------------------------------------------------------------

    axis_3.set_xlabel(PRETTY_PRINT_ATTRIBUTES[x_axis_field] + ", " + '\nExperiment Duration='
                      + str(timedelta(seconds=duration_seconds)), fontsize=8)

    plt.suptitle(experiments[0].to_plot_title(x_axis_field) + ' \nvs ' + PRETTY_PRINT_ATTRIBUTES[x_axis_field],
                 fontsize=8)
    plt.tight_layout()
    plt.subplots_adjust(top=0.9)
    # plt.show()
    if plotted_file_name is not None:
        print('Saving ' + plotted_file_name)
        plt.savefig(plotted_file_name, pad_inches=0.2, dpi=400)

    return figure_1


def plot(axis, x_data, y_data, param_dict, plot_label='', error=None):
    """
    Plot helper function per matplotlib coding styles:
     https://matplotlib.org/tutorials/introductory/usage.html#sphx-glr-tutorials-introductory-usage-py

    :param error:
    :param axis:
    :param x_data:
    :param y_data:
    :param param_dict:
    :param plot_label:
    :return:
    """
    if validate_error(error):
        return axis.errorbar(x_data, y_data, error, elinewidth=0.8, label=plot_label, **param_dict)
    else:
        return axis.plot(x_data, y_data, label=plot_label, **param_dict)


def validate_error(error):
    if error is None:
        return False

    # todo check values: Apex experiments can have Nan or Inf
    for e in error:
        if e is None:
            return False
    return True


def plot_dict_with_axis(output_pdf_file, experiments_dict, x_axis):
    """

    :param output_pdf_file:
    :param experiments_dict:
    :param x_axis:
    :return:
    """
    with matplotlib.backends.backend_pdf.PdfPages(output_pdf_file) as pdf:

        for key in sorted(experiments_dict.keys()):
            value = experiments_dict[key]
            experiment_list = []
            for file in value:
                print(file)
                experiment_list.append(read_file_as_data_frame(file))

            if len(experiment_list) > 0:
                # sort the list by the desired x_axis attribute
                experiment_list = sorted(experiment_list, key=operator.attrgetter(x_axis))
                f = plot_all(x_axis, experiment_list)
                pdf.savefig(f)
        plt.clf()


def read_and_plot_files(base_directory):
    """

    :param base_directory:
    :return:
    """

    # we plot with the x-axis as a function of rate or subscribers
    # to plot we need to grab files by same rate and same subscription

    dirs = os.listdir(base_directory)
    for directory in dirs:

        if validate_topic(directory):

            try:
                # each directory in the experiment directory is a specific topic
                print('Entering ' + directory)
                for root, _dirs, files in os.walk(base_directory + '/' + directory):

                    rates = defaultdict(list)  # dict containing the filenames of the various rates
                    subs = defaultdict(list)   # dict containing the filenames of the various subscriptions

                    for file in files:

                        full_file_name = os.path.join(root, file)
                        if os.path.isfile(full_file_name):
                            if ".log" in file and 'data' not in file \
                                    and 'system' not in file and 'experiment' not in file:

                                _r, _s = get_rate_and_subscribers_from_file(file)
                                rates[int(_r)].append(full_file_name)
                                subs[int(_s)].append(full_file_name)

                            else:
                                print('    Skipping ' + file)
                        else:
                            print('    Skipping ' + file)

                    # plot the varying message rates with an x-axis of the number of subscribers
                    plot_dict_with_axis(os.path.join(root, directory + '_subscribers.pdf'), rates, 'num_subscribers')
                    # plot the varying number of subscribers with an x-axis of the message rate
                    plot_dict_with_axis(os.path.join(root, directory + '_rates.pdf'), subs, 'rate')

            except Exception as e:
                print(e)
            print('----')


def get_rate_and_subscribers_from_file(file_name):
    # todo put in the run_relational_experiment module as this owns the file name generation
    """
    Get the rate and number of subscribers from the file name (specified by the run_relational_experiment.py module).

    :param file_name: input file name to parse rate and number of subscribers, e.g., topicPointCloud512k_rate10_p1_s5
    :return: message rate and number of subscribers
    """
    split = file_name.split('.log')[0].split('_')
    return int(split[1].replace('rate', '')), int(split[3].replace('s', ''))


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='Plot ROS2 Performance Tests')
    parser.add_argument('-d', '--directory', help='base directory containing all topic subdirectories'
                                                  + '(output of run_relational_experiment.py)', default=".")
    args = parser.parse_args()

    base_dir = args.directory

    if not os.path.isdir(base_dir):
        raise ValueError('input directory is not valid: ' + base_dir)

    read_and_plot_files(base_dir)
